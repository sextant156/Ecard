var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { parsePath } from 'history';
import { history, prependBasename } from './history';
import { RouterConfig } from './router';
import stacks from './router/stack';
import { addLeadingSlash, routesAlias } from './utils';
function processNavigateUrl(option) {
    var _a;
    const pathPieces = parsePath(option.url);
    // 处理相对路径
    if ((_a = pathPieces.pathname) === null || _a === void 0 ? void 0 : _a.includes('./')) {
        const parts = routesAlias.getOrigin(history.location.pathname).split('/');
        parts.pop();
        pathPieces.pathname.split('/').forEach((item) => {
            if (item === '.') {
                return;
            }
            item === '..' ? parts.pop() : parts.push(item);
        });
        pathPieces.pathname = parts.join('/');
    }
    // 处理自定义路由
    pathPieces.pathname = routesAlias.getAlias(addLeadingSlash(pathPieces.pathname));
    // 处理 basename
    pathPieces.pathname = prependBasename(pathPieces.pathname);
    // hack fix history v5 bug: https://github.com/remix-run/history/issues/814
    if (!pathPieces.search)
        pathPieces.search = '';
    return pathPieces;
}
function navigate(option, method) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
            stacks.method = method;
            const { success, complete, fail } = option;
            const unListen = history.listen(() => {
                const res = { errMsg: `${method}:ok` };
                success === null || success === void 0 ? void 0 : success(res);
                complete === null || complete === void 0 ? void 0 : complete(res);
                resolve(res);
                unListen();
            });
            try {
                if ('url' in option) {
                    const pathPieces = processNavigateUrl(option);
                    const state = { timestamp: Date.now() };
                    if (method === 'navigateTo') {
                        history.push(pathPieces, state);
                    }
                    else if (method === 'redirectTo' || method === 'switchTab') {
                        history.replace(pathPieces, state);
                    }
                    else if (method === 'reLaunch') {
                        stacks.delta = stacks.length;
                        history.replace(pathPieces, state);
                    }
                }
                else if (method === 'navigateBack') {
                    stacks.delta = option.delta;
                    history.go(-option.delta);
                }
            }
            catch (error) {
                const res = { errMsg: `${method}:fail ${error.message || error}` };
                fail === null || fail === void 0 ? void 0 : fail(res);
                complete === null || complete === void 0 ? void 0 : complete(res);
                reject(res);
            }
        });
    });
}
export function navigateTo(option) {
    return navigate(option, 'navigateTo');
}
export function redirectTo(option) {
    return navigate(option, 'redirectTo');
}
export function navigateBack(option = { delta: 1 }) {
    if (!option.delta || option.delta < 1) {
        option.delta = 1;
    }
    return navigate(option, 'navigateBack');
}
export function switchTab(option) {
    return navigate(option, 'switchTab');
}
export function reLaunch(option) {
    return navigate(option, 'reLaunch');
}
export function getCurrentPages() {
    if (process.env.NODE_ENV !== 'production' && RouterConfig.mode === 'multi') {
        console.warn('多页面路由模式不支持使用 getCurrentPages 方法！');
    }
    const pages = stacks.get();
    return pages.map(e => { var _a; return (Object.assign(Object.assign({}, e), { route: ((_a = e.path) === null || _a === void 0 ? void 0 : _a.replace(/\?.*/g, '')) || '' })); });
}
